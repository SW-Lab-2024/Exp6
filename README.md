# Exp6
Object Oriented Design Patterns and Code Refactoring in Java

# فاز دوم

## Facade
- کلاس ParserFacade یک اینترفیس ساده را برای کلاینت‌ها فراهمخ می‌کند و وابستگی و پیچیدگی پارسر را پنهان می‌کند. اگر پیاد‌ه‌سازی parser عوض شود، کلاینت نیازی به عوض کردن facade ندارد. همچنین Main را برای استفاده کردن از این Facade اپدیت می‌کنیم.
- همچنین برای کلاس Token،‌یک Facade تعریف کرده‌ایم تا برای کلاینت‌ها ارتباط با عملکرد‌های مربوط به توکن تسهیل شود. این Facade، لاجیک ایجاد توکن و مشخص کردن تایپ آن را encapsulate می‌کند. همچنین lexicalAnalyzer برای استفاده از این Facade اپدیت شده است.

## Replace condition with polymorphism

برای این امر ابتدا یک کلاس پدر با ابسترکت متود toString تعریف می‌کنیم. سپس برای هر تایپ آدرس جداگانه یک کلاس که از این کلاس پدر ارث‌بری می‌کنند، نوشته و برای هرکدام متود toString را جداگانه پیاده سازی می‌کنیم.

## Separate query from modifier

در کلاس ErrorHandler، در متود printError، هم استیت فیلد hasError عوض می‌شد و هم لاگ ارور چاپ می‌شد. به این کلاس چند تابع جدید اضافه شد. اکنون فیلد hasError از طریق تابع hasError قابل دسترسی است و می‌توان به آن کوئری زد. همچنین این فیلد پرایوت شده است تا از کلاس‌های دیگر، قابل دسترسی نباشد. همچنین تابع setError، برای عوض کردن استیت hasError نوشته شده است.


# سوالات

# سوال ۱ 
-  الگو‌های خلاقانه: در این الگو به فرآیند ایجاد ابجکت‌ها و نمونه‌ها می‌پردازد و هدف آن مدیریت و کنترل فرآیند ساخت ابجکت‌ها به روشی انعطاف‌پذیر می‌باشد. یکی از این الگو‌ها Singleton است ک مطمئن می‌شود کخ تنها یک اینستنس از یک کلاس وجود دارد.
- الگو‌های ساختاری: تمرکز این دسته برروی ترکیب ابجکت‌ها و کلاس‌ها برای تشکیل ساختار‌های بزرگ‌نر و پیچیده‌تر می باشد. الگو‌های Adapter و Composite در این دسته قرار می گیرند و به دولوپر‌ها امکان مدیریت بهینه روابط بین ابجکت‌ها را می‌دهد.
- الگو‌های رفتاری: ایم الگو‌ها به تعاملات بین ابجکت‌ها و کلاس‌ها می‌پردازد. نحوه ارتباط بین ابجکت ها را تعریف می‌کنند تا وظایف به طور م.ثر تقسیم شوند. الگو Strategy از این دسته می‌باشد.
# سوال ۴
در وهله ی اول مهم تر از همه این الگو  (Single Responsibility Principle SRP) را نقض میکند چون الگوی Singleton وظیفه مدیریت ایجاد و دسترسی به تنها یک نمونه از کلاس را به دوش می‌کشد. این ترکیب وظایف ممکن است باعث نقض SRP شود زیرا کلاس علاوه بر وظیفه اصلی خود، مسئولیت مدیریت چرخه حیات خود و هرگونه responsibility دیگر را نیز بر عهده خواهد داشت.


این طراحی اصل باز/بسته (Open/Closed Principle) را نقض می‌کند، زیرا کلاس Singleton خودش مسئول ایجاد نمونه‌اش است، در حالی که مصرف‌کنندگان معمولاً به طور سخت به نمونه واقعی آن وابسته می‌شوند. این وابستگی باعث می‌شود که تغییر پیاده‌سازی بدون انجام تغییرات گسترده در سراسر برنامه ممکن نباشد.

این طراحی همچنین اصل وارونگی وابستگی (Dependency Inversion Principle یا DIP) را نقض می‌کند، زیرا مصرف‌کنندگان همیشه مستقیماً به کلاس واقعی برای دریافت نمونه وابسته خواهند بود، در حالی که DIP توصیه می‌کند که از انتزاع‌ها استفاده شود. این امر باعث می‌شود که پیاده‌سازی Singleton به صورت غیرقابل جدایی همراه برنامه باقی بماند و از اضافه کردن مسائل فرعی، مانند تزئین‌کننده‌ها یا توزیع مشتری بدون پیاده‌سازی Singleton، جلوگیری می‌کند.

در این طراحی همچنین (Liskov Substitution Principle LSP) محقق نمی‌شود، دروافع الگوی Singleton اغلب به ارث‌بری نیاز ندارد و در صورت ارث‌بری، می‌تواند مشکل‌ساز شود زیرا نمونه جدید نمی‌تواند جایگزین نمونه Singleton شود، که این موضوع باعث نقض LSP می‌شود.

اصل Interface Segregation Principle (ISP) نقض نمیشود چون ارتباط چندانی با این مدل ندارد زیرا این اصل مرتبط با تفکیک وظایف در اینترفیس‌ها است، که در مورد Singleton اصولاً مشکلی ایجاد نمی‌کند.


# سوال ۵
clean code: اگر کد یک سری ویژگی که در ادامه به آنها اشاره میکنیم داشته باشد به آن کد تمیز میگوییم.اول از همه این مورد به خوانایی کد اشاره میکند علی الخصوص برای دیگر برنامه نویس ها.مثلا باید حواسمان به نام گذاری متغیر ها و شلوغ نبودن کلاس ها و توابع باشد.

هدف از مورد دوم ایچاد سادگی در تغییر کد است لذا باید از تکراری بودن بخش های مختلف کد حتی الامکان پرهیز شود که موقع تغییر تنها بخواهیم یک بخش از کد را تغییر دهیم که بدیهی است در غیراینصورت شاهد کندی فرایند خواهیم بود.
هدف از مورد سوم هم راحتی در نگه داری از کد است.ما برای تحقق این امر،باید کد هرچه کمتر و تمیزتری داشته باشیم.
در راستای تحقق مورد چهارم هم باید بدانیم که کد ما اهداف کدنظرمان را محقق میکند پس با رعایت تمیزی پاس شدن تست هایمان را به دنبال خواهیم داشت.
پس کلا هدف از کد تمیز صرفه جویی در زمان است که از طریق تمیزی کد و پیشگیری از سردرگمی برنامه نویس و بهینه سازی هرگونه عملیات مدنظر است.بهینه سازی برای ما به معنی هم داشتن بهترین عملکرد بوده و هم پیشگیری از انجام کار های اضافه و وجود بخش های اضافه و تکراری در کد.

Technincal Debit:  چبدهی فنی به این معناست که شنا فرض کنید یک خرید خاصی مدنظرتان است که هرچه سریعتر میخواهید به آن برسید.هرچند از عهده ی شمار خارج است پس به سراغ وام با سود میروید.بدیهتا در نهایت این شما هستید که در بلندمدت ضرر میکنید چون برای تسریع در یک فرایند شما مچبور به تهیه وام شدید و این موضوع در لحظه برای شما سوداور همین مسئله راجع به  بدهی فنی صدق میکند. فرض کنید تحت شرایط فشار کسب کار مجبور شدید که کدی را سریع به کارفرمای خو تحویل بدهید که هیچ گونه از اصول کد تمیز در آن رعایت نشده و اصلا برنامه تست ندارد.شاید در آن موعد شما کارتان را تحویل داده باشید اما در طولانی مدت هزینه ی زیاد مالی و زمانی بر تیم تحمیل خواهد شد.در طی این شرایط ما ممکن است به بدهی فنی بر بخوریم:فشار کسب کار،عدم آشنایی با اهمیت بازآرایی،نبود تست و مستند سازی،بازآرایی دیرهنگام،توسعه ی طولانی مدت کد در برنچ های مختلف(به وضوح پس از مدت طولانی به تناقضات بسیار در کد برمیخوریم،پس هرچقد کدنویسی ما ازیوله تر باشد،ریسک بدهی فنی بیشتر است) و همچنین نبود تعامل بین اعضای تیم به علت مشابه برای ما بدهی فنی خواهد ساخت.


code smells: بوهای کد نشانگر مشکلاتی هستند که می توان در طی بازسازی مجدد آنها را برطرف کرد. بوی کد به راحتی قابل تشخیص و رفع است، اما دایم هم میتواند علائم یک مشکل عمیق تر باشد.
# سوال ۶

بوهای کد نشانگر مشکلاتی هستند که می توان در طی بازسازی مجدد آنها را برطرف کرد. بوی کد به راحتی قابل تشخیص و رفع است، اما هی ممکن است فقط علائم یک مشکل عمیق تر باشد با کد


بادکننده ها: Bloaters کدها، روش‌ها و کلاس‌هایی هستند که به بسیار بزرگ شدند و کار کردن با آنها دشوار است. معمولاً این بوها فوراً ظاهر نمی‌شوند، بلکه در طول زمان ظی تکامل برنامه روی هم انباشته می‌شوند (علی الخصوص وقتی کسی تلاشی برای از بین بردن آنها نمیکند).مثال:
روش طولانی،کلاس بزرگ،وسواس اولیه،لیست پارامترهای طولانی،مجموعه داده ها

استفاده ناصحیح از اصول شی گرا: همه این بوها کاربرد ناقص یا نادرست اصول برنامه نویسی شی گرا هستند.برای مثال:
کلاس های جایگزین با واسط های مختلف،رد کردن وصیت ها،و بند های switch،فیلد موقت

مانع ساز های تغییر:

این بوها در شرایطی ایجاد می شوند که شما نیاز به تغییر چیزی در یک مکان در کد خود دارید، باید در جاهای دیگر نیز تغییرات زیادی ایجاد کنید. در نتیجه توسعه برنامه بسیار پیچیده تر و گران تر می شود. مثال ها:

تغییر واگرا،سلسله مراتب وراثت موازی،جراحی تفنگ ساچمه ای

بی مصرف ها!:

یک چیز بی‌معنی و غیر ضروری است که نبود آن کد را پاک‌تر، کارآمدتر و درک آسان‌تر می‌کند.رویکردها:
نظرات،کد تکراری،کلاس داده،کد مرده،کلاس تنبل،عمومیت گمانه زنی

جفت کننده ها:

تمام بوهای موجود در این گروه به جفت شدن بیش از حد بین کلاس ها اطلاق می شود یا نشان می دهد که اگر جفت با تفویض بیش از حد جایگزین شود چه اتفاقی می افتد.مثال:
حسادت به فیچر ها!صمیمیت نامناسب،کلاس کتابخانه ناقص،زنجیره پیام،مرد وسطی
# سوال ۷
کلاس تنبل در دسته ی بی مصرف ها(Dispensables) قرار میگیرد.

برای برطرف کردن آن درمولفه های تقریبا بی استفاده از بازارایی کلاس خطی (اگر یک کلاس نقش خاص و مسئولیت مهمی را در پروژه به عهده ندارد تمام فیچر ها و ویژگی های آن را به یک کلاس دیگر منتقل میکنیم) استفاده شده و همچنین برای رفع آن برای زیرکلاسی که توابع محدودی را دارد از روش فروپاشی سلسله مراتب(اگر زیرکلاس عملا مانند کلاس مرتبه بالاتر خود باشد باید زیر کلاس را با کلاس بالایی ادغام کنیم) میتوان استفاده کرد.

زمانی میتوان آن را در نظر نگرفت که این کلاس های تنبل برای مشخص سازی اهداف برای توسعه های آتی ایجاد شده اند.در این شرایط باید به دنبال ایجاد تعادل بین سادگی و وضوح کد باشیم.

# سوال ۸ 
- در کلاس ClassInfo، مقدار magic value  وجود دارد و نمی‌توان دلیل اسکیپ کردن ۳ کاراکتر ابتدایی توکن در خط ۵۷ را فهمید.
- عدم وحود کامنت کافی 
- در کلاس Phase2CodeFileManipulator یک سوییچ کیس بزرگ و پیچیده وجود دارد.
- همچنین این کلاس Phase2CodeFileManipulator بسیاز بزرگ است و باید به تکه‌های کوچکتر تقسیم شود.
- در کلاس LexicalAnalyzer متود بسیار طولانی وجود دارد.
- عدم encapsulate کردن فیلد‌هایی که فقط در کلاس استفاده می شوند.
- در سراسر پروژه ارور‌ها با دقت و به اندازه کافی هندل نشده‌اند.
- در کلاس MethodOverLoader، مقدار hard-code شده وجود دارد. (حروف الفیا)
- به اندازه کافی یونیت تست نوشته نشده است.
- وجود dead code در بعضی از کلاس‌ها.
- در کلاس Phase1CodeGenerator، کد تکراری برای ساخت فایل و دایرکتوری وجود دارد.
- نامگذاری متود isSuccessFull اشتباه است و باید isSuccessful باشد.
 # سوال ۹
پلاگین Formetter مطابق مستند ارائه شده از خود سایت آن یک موجو پلاگین Maven برای قالب‌بندی کد منبع جاوا با استفاده از فرمت‌کننده کد Eclipse.برای مثال پارامترهای Mojo با مشخص کردن فایل پیکربندی XML، انتهای خطوط، نسخه کامپایلر و مکان کد منبع، قالب‌بندی را سفارشی سازی می‌کنند. از قالب‌بندی مجدد فایل‌های منبع با استفاده از هش sha512 محتوا، در مقایسه با هش اصلی به هش پس از قالب‌بندی و هش حافظه پنهان، اجتناب می‌شود.
اینجا چند نمونه از پارمترهای داده شده مشاهده میکنیم.

همچنین مثالی از قابلیت های مشخص کردن پارامترهای دلخواه در پیکربندی XML مشاهده مینماییم:
ورژن کامپایلر:
<configuration>
    <compilerSource>1.9</compilerSource>
    <compilerCompliance>1.9</compilerCompliance>
    <compilerTargetPlatform>1.9</compilerTargetPlatform>
  </configuration>
فرمت encoding:
<plugin>
  <groupId>net.revelc.code.formatter</groupId>
  <artifactId>formatter-maven-plugin</artifactId>
  <version>2.24.2-SNAPSHOT</version>
  <configuration>
    <encoding>UTF-8</encoding>
  </configuration>
</plugin>

## ارتباط این پلاگین با Refactoring
افزودن پارامتز  های مختلف این پلاگین مانند این است که ما یک دستور کارو مشی کلی در کدنویسی مان داریم که در کل پروژه ناگزیر رعایت می شود.نوشتن یک مشی کلی از اضافه نویسی پرهیز کرده و به ما به روش بهتری کد تمیز را میدهد.برای مثال خیلی صریح و مستقیم با پارامتر complier version یا ecnoding پارامتر مربوطه را مشخص میکنند و اینگونه هر برنامه نویسی میتواند از یک فرمت پروژه استفاده کند و از ناهماهنگی و مشکلات ران شدن از این قبیل به سادگی میتوان پیشگیری کرد و مطمئنیم به ارور های ازین دست(ناهماهنگی مشارکت کننده ها باهم) نمیخوریم.
و همچنین به سادگی میتوان با پارامتر های <include > و<exclude> بخش هایی که از formatting استفاده میکنند را مشخص نمود.




